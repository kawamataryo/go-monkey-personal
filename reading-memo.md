# 今わからない事
- Goのinterface
    - どう関連づけしているの？
    - どこが実装しているの？
    - 型定義として使ってはいる。ただ、普通のTypeとの違いは何なんだろう
    - 型にはinterfaceとstructがある
    - interfaceは実態を作れないんだと思う
    - 参考 http://cuto.unirita.co.jp/gostudy/post/interface/
        - インタフェースの実装に明示的な宣言が必要なJavaやC#と違い、 Go言語ではインタフェースが必要とするメソッドをすべて実装した時点で、自動的にそのインタフェースを実装したとみなされます。
- `stmt.(*ast.ReturnStatement)`の呼び出し形式
    - ポインタを呼び出す？？
- `a, ok := someone.(Animal)`のやつ
    - そのmethodがあるかどうかの判定ぽい？?
    
# メモ
- Goではオブジェクト指向は出来ない。structで関数を追加していくだけ。
- 式の構文解析は難しい。演算子の優先順位とかも考える必要がある
- 式は値を返し、文は値を返さない
- Vaughan Pratt トップダウン演算子優先順位構文解析 で式の構文解析をする
    
# パーサー（構文解析機）
入力をあるデータ構造へと変換するもの。JSON.parse()みたいなもの。
- 構文木と抽象構文木
- 抽象構文木は、セミコロン、改行文字、ホワイトスペースなどが省かれる
- 期待された構造に従っているかも検証する
- パーサージェネレーター。yacc, bison, ANTLR、何らかの言語の記述を受け取って、その出力としてパーサーを生成する。便利なものもあるんだな。

# 用語メモ
- オペランド => 演算対象
- 前置演算子 => オペランドの前に置かれる演算子（`--5`の`--`とか）
- 後置演算子 => オペランドの後に置かれる演算子（`foobar++`の`++`とか）
- 中置演算子 => オペランドの中央に置かれる演算子 (`1 + 5`の`+`）
- 二項演算子式 => 中置演算子を含むオペランドが二つの式
- 式文 => 式だけからなる行（`x + 10`とか）


構文解析の戦略については大きく分けて2つ。トップダウン構文解析と、ボトムアップ構文解析。
トップダウン構文解析は、ルートノードから構築していく。
ボトムアップ構文解析は、その逆

トップダウン構文解析にもいくつか種類がある。
- 再帰下降構文解析
- アーリー法
- 予測的構文解析

式は値を生成し、文はしない。

letとreturnの構文解析。
letを構文解析するとは？ => 変数束縛を表現する？


# 字句解析
ソースコードからトークン列への変換を字句解析という。
プログラミングコードから空白、コメントなどを取り除き意味を持つ文字列の配列を作り出す。
- 認識したトークンを順に一行ずつ出力する
- ソースコードを与えて初期化し、順に`NextToken()`を読んでソースコードを進めていく
- トークンごと、文字ごとに進む
- stringを受け取りTokenを返す


# Goの文法

### `:=`
変数の宣言と代入を一度にやる。関数の内部でしか使えない。
Short variable declarations
https://tour.golang.org/basics/10

### `&型名`
どうやら型のポインタを抽出するらしい..

### `type 名前 struct {}`
構造体を作る。任意の型をまとめたもの。

### `func (型名) 関数名() {}`
構造体のメソッドを定義する？

### `len`
letは名前空間が関数内に限定されるぽい。JSのletと同じ

### メモ
- エクスポートしている名前は大文字になる
- `naked return` 戻り値に名前をつける
- 変数に初期値を与えず宣言するとそれぞれの型のデフォルト値となる。数値型は`0`、bool型は`false`, string型は`""`
- 型のキャストもできる
- whileはなくて`for sum < 100`みたいに記述できる
- if式の前でifで使う計算をすることができる`if v := math.Pow(x, n); v < lim {` ここでのvはifの中でしか使えない。
- Goのcase文では`break`は自動的に実行される
- Goのcase文では式を評価できる。ifの大体ができる
- `Defer`呼び出しを関数スコープのreturnが呼ばれるまで遅延させる。複数ある場合は、スタック的に最後に入れたのから呼ばれるぽい。
- structのポインタは、`(*p).V`みたいな形式でかかずとも`p.V`でフィールドにアクセスできる
- Goの配列は長さ固定？`[10]int`みたいに指定する。
- 可変長の配列。スライスを作ることもできる`[]int`で表される？スライスは配列への参照のようなもの。
- スライスへの変更は元の配列への変更となる。
- スライスを直接初期化する場合は`[]bool{true, false}`みたいにする。長さの指定は不要。
- スライスの`low : high`はデフォルト値がある`a[:]`の場合は`a[0 : （配列aの最大の添字)]`となる
- スライスは`len(slice)`と`cap(slice)`で長さを取得できる。`len`はスライスの長さ、`cap`はスライスの最初の要素から、元となる配列の要素数。
- appendで複数追加する時capが+1されるのなぜ？？


# Goのテスト
t.Fatal()を使う。これが呼ばれるとテストが落ちる。正常系だと呼ばれない。なるほど。。全然考え方が違う
https://golang.org/pkg/testing/

# Goのパッケージのパス
好きなところに置いていいわけではない..!!
https://hodalog.com/golang-standard-project-layout/

# アドレスとポインタ
アドレス..メモリ上のある場所、変数や式が格納されている
ポインタ変数..メモリ上のアドレスを値として入れられる変数のこと

構造体の参照渡しをする時は`&`で型からポインタを取り出して行う

# Go動画メモ
https://www.youtube.com/watch?v=kPXfMFJ0oIE

- Cに近い
- 仮想マシンはない
- Goのエントリーポイントはmain()


# 参考
[Goで学ぶポインタとアドレス - Qiita](https://qiita.com/Sekky0905/items/447efa04a95e3fec217f)
