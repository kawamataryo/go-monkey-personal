# 字句解析
ソースコードからトークン列への変換を字句解析という。
プログラミングコードから空白、コメントなどを取り除き意味を持つ文字列の配列を作り出す。


# Goの文法

### `:=`
変数の宣言と代入を一度にやる。関数の内部でしか使えない。
Short variable declarations
https://tour.golang.org/basics/10

### `&型名`
どうやら型のポインタを抽出するらしい..

### `type 名前 struct {}`
構造体を作る。任意の型をまとめたもの。

### `func (型名) 関数名() {}`
構造体のメソッドを定義する？

### `len`
letは名前空間が関数内に限定されるぽい。JSのletと同じ

### メモ
- エクスポートしている名前は大文字になる
- `naked return` 戻り値に名前をつける
- 変数に初期値を与えず宣言するとそれぞれの型のデフォルト値となる。数値型は`0`、bool型は`false`, string型は`""`
- 型のキャストもできる
- whileはなくて`for sum < 100`みたいに記述できる
- if式の前でifで使う計算をすることができる`if v := math.Pow(x, n); v < lim {` ここでのvはifの中でしか使えない。
- Goのcase文では`break`は自動的に実行される
- Goのcase文では式を評価できる。ifの大体ができる
- `Defer`呼び出しを関数スコープのreturnが呼ばれるまで遅延させる。複数ある場合は、スタック的に最後に入れたのから呼ばれるぽい。
- structのポインタは、`(*p).V`みたいな形式でかかずとも`p.V`でフィールドにアクセスできる
- Goの配列は長さ固定？`[10]int`みたいに指定する


# Goのテスト
t.Fatal()を使う。これが呼ばれるとテストが落ちる。正常系だと呼ばれない。なるほど。。全然考え方が違う
https://golang.org/pkg/testing/

# Goのパッケージのパス
好きなところに置いていいわけではない..!!
https://hodalog.com/golang-standard-project-layout/

# アドレスとポインタ
アドレス..メモリ上のある場所、変数や式が格納されている
ポインタ変数..メモリ上のアドレスを値として入れられる変数のこと

構造体の参照渡しをする時は`&`で型からポインタを取り出して行う



# 参考
[Goで学ぶポインタとアドレス - Qiita](https://qiita.com/Sekky0905/items/447efa04a95e3fec217f)